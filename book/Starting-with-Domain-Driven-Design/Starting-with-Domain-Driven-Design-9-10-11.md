# 도메인 주도 개발 시작하기

이 글은 [도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지](https://product.kyobobook.co.kr/detail/S000001810495) 책을 읽고 정리한 내용이다.

아래 9,10,11장 내용은 책에서 중요한/기억하고자하는 내용 위주로 정리했다. 자세한 내용은 책을 참고하자.


---

## 9장. 도메인 모델과 바운디드 컨텍스트

한 개의 모델로 모든 하위 도메인 모델을 표현하려는 시도는 올바른 방법이 아니며 표현할 수 없다.

* 예를 들어, 상품, 카탈로그, 재고 -> 각 모델별로 다른 모델을 보는 시각이 다르기 때문에, 하위 도메인에 따라 다른 용어와 의미를 사용한다.

같은 제품이라도 서로 의미가 다르기 때문에, 이렇게 구분되는 경계를 갖는 컨텍스트를 도메인 주도 설계 에서는 `바운디드 컨텍스트`라고 부른다.


### 9.2 바운디드 컨텍스트

바운디드 컨텍스트는 모델의 경계를 결정하며, 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다. 용어를 기준으로 구분한다.

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋지만, 현실은 그렇지 않은 경우가 많다.

아래 그림 9.2와 같이 바운디드 컨택스트는 기업의 팀 조직 구조(규모)에 따라 결정되기도 한다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-9-1.png)

만약 규모가 작은 조직 또는 기업이라면 아래 그림 9.3과 같이 여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현할 수도 있다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-9-2.png)

이런 경우에는 하위 도메인마다 구분되는 패키지를 갖도록 구현해서 하위 도메인을 위한 모델이 서로 뒤섞이지 않도록 하는 것이 중요하다.


### 9.3 바운디드 컨텍스트 구현

모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.

도메인 기능 자체가 단순하면 서비스 - DAO 로 구성된 CRUD 방식으로 사용해도 유지보수하는데 문제가 되지 않는다고 생각한다.

하나의 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수 있는데, 대표적인 예시가 CQRS 패턴이다.

명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴으로, 아래 그림 9.7과 같이 상태 변경과 관련된 기능은 도메인 모델 기반으록 ㅜ현하고, 조회 기능은 서비스-DAO를 이용해서 구현할 수 있다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-9-3.png)


### 9.4 바운디드 컨텍스트 통합

(1) REST API를 이용한 직접 통합은 한 컨텍스트가 다른 쪽을 즉시 호출하고 응답을 받는 방식으로, 

  호출하는 쪽에서 외부 모델을 자신의 도메인 모델로 변환하는 책임을 진다.

반면, (2) 메시지 큐를 이용한 간접 통합은 한쪽이 메시지를 발행하고 다른 쪽이 구독하는 비동기 방식으로,

  시스템 간의 결합도를 낮춰 장애 전파를 막아준다.

두 방식 모두 외부 데이터를 그대로 사용하지 않고 자신의 모델로 변환하여 **도메인의 경계를 보호**하는 것이 중요하다.


### 9.5 바운디드 컨텍스트 간 관계

바운디드 컨텍스트는 독립적으로 존재하기보다 서로 통합되는 경우가 많으며, 이때 여러 가지 관계를 맺게 된다.

#### 상류 - 하류 관계

가장 흔한 관계는 한쪽이 API를 제공(상류, Upstream)하고 다른 쪽이 그 API를 사용하는(하류, Downstream) 구조이다.

이는 마치 **공급자와 고객의 관계**와 같다.

* `상류 (Upstream)팀`: 서비스 공급자. 다른 팀이 사용할 API를 제공한다. (책의 예시: 추천 시스템)

* `하류 (Downstream)팀`: 서비스 고객. 상류 팀의 API를 호출해서 사용한다. (책의 예시: 카탈로그 시스템)

이 관계에서는 하류 팀이 상류 팀에 의존하므로, 상류 팀이 마음대로 API를 바꾸면 하류 시스템이 망가질 수 있다.

따라서 두 팀 간의 긴밀한 소통과 일정 협의가 필수적이다.

상류 팀이 여러 하류 팀에게 일관된 서비스를 제공할 때, 이를 `공개 호스트 서비스(Open Host Service)` 라고 부른다.

* 대표적인 예시가 `검색`이다.

* 블로그, 카페, 게시판과 같은 서비스를 제공하는 포털은 각 서비스별로 검색 기능을 구현하기 보다는 검색을 위한 전용 시스템을 구축하고 검색 시스템과 각 서비스를 통합한다.

* 이때 검색 시스템이 `상류 컴포넌트`가 되고 블로그, 카페, 게시판은 `하류 컴포넌트`가 된다.

* 상류 팀은 각 하류 컴포넌트의 요구사항을 수용하는 단일 API를 만들어 이를 공개하고, 각 하류 팀은 공개된 API를 사용해서 검색 기능을 구현한다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-9-4.png)

#### 안티코럽션 계층

하류 컨텍스트는 상류 컨텍스트의 모델(데이터 형식)이 자신의 도메인 모델을 오염시키는 것을 막아야 한다.

이때 사용하는 것이 **`안티코럽션 계층(ACL)`** 이다.

이 계층은 하류 컨텍스트의 인프라스트럭쳐 영역에 위치하며, 다음과 같은 역할을 수행한다.

* 상류 시스템의 API를 호출한다.

* 상류 시스템의 데이터 모델을 하류 시스템의 도메인 모델로 변환한다.

아래 그림 9.19 처럼 ResSystemClient 는 외부 시스템과의 연동을 처리하는데 외부 시스템의 도메인 모델이 내 도메인 모델을 침범하지 않도록 막아주는 역할을 한다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-9-5.png)

이러한 계층 덕분에 하류 컨텍스트는 외부의 변화에 영향을 받지 않고 자신의 모델 순수성을 지킬 수 있다.


## 10장. 이벤트

* 외부 서비스의 정상이 아닐 경우(e.g. 네트워크 타임아웃)

* 외부 시스템의 성능에 직접 영향을 받는 문제

* 도메인 로직에 서로 다른 도메인이 섞이는 문제 -> 강결합

이러한 강한 결합을 없애는 방법은 `이벤트`를 사용하는 것이다.

### 10.2 이벤트 개요

여기서 사용하는 이벤트의 용어는 `과거에 벌어진 어떤 것`을 의미한다.

이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

이벤트 관련 구성 요소는 아래 그림 10.3과 같이 네 개의 구성 요소를 가진다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-10-1.png)

* 구성 요소: 이벤트, 이벤트 생성 주체, 이벤트 디스패처(이벤트 퍼블리셔), 이벤트 핸들러(이벤트 구독자)

* `이벤트 생성 주체`는 엔티티, 밸류, 도메인 서비스와 같은 도매인 객체이다.

* `이벤트 디스패처`는 이벤트 생성 주체로부터 전달받은 이벤트를 이벤트 핸들러에게 전파한다. 구현 방식에 따라 동기/비동기로 실행하게 된다.

* `이벤트 핸들러`는 이벤트 생성 주체가 발생한 이벤트에 반응한다. 생성 주체가 발생한 이벤트를 전달받아 담긴 데이터를 이용해서 원하는 기능을 실행한다.

  * 예를 들어 '주문 취소됨 이벤트'를 받는 이벤트 핸들러는 해당 주문의 주문자에게 SMS로 주문 취소 사실을 통지할 수 있다.


> 이벤트의 구성

* 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현 (과거 시제) (e.g. OrderCanceledEvent)

* 이벤트 발생 시간

* 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보


> 이벤트의 용도

이벤트는 크게 두 가지 용도로 사용한다.

1. 트리거 -> 도메인의 상태가 바뀔 때 다른 후처리가 필요할 때, 후처리를 실행하기 위한 트리거로 이벤트를 사용한다.

2. 동기화 -> 서로 다른 시스템간의 데이터 동기화 


> 이벤트의 장점

이벤트를 사용하면 다음과 같은 장점을 가진다.

* 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다. 

  * 예를 들어, 구매한 주문을 취소한다고 가정을 하면 주문 도메인에서 주문 상태를 '취소'로 변경한 뒤, 주문 취소 이벤트를 생성함으로써 환불 로직을 없앨 수 있다.

  * 이벤트를 사용해서 주문 도메인에서 결제(환불) 도메인으로의 의존을 제거했다.

* 이벤트 핸들러를 사용하면 기능 확장도 용이하다.

  * 구매 취소 시 환불과 함께 **이메일 발송**을 처리하는 핸들러를 구현하면 된다.

이처럼 이벤트를 사용하면 아래 그림 10.6과 같이 표현할 수 있다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-10-2.png)


### 10.3 이벤트, 핸들러, 디스패처 구현

이벤트와 관련된 코드는 다음과 같다.

* 이벤트 클래스: 이벤트를 표현한다.

* Events: 이벤트를 발행한다. 이벤트 발행을 위해 `ApplicationEventPublisher` 를 사용한다.

* 디스패처: 스프링이 제공하는 `ApplicationEventPublisher` 를 이용한다.

* 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.

#### 이벤트 클래스

이벤트는 과거에 벌어진 상태 변화나 사건을 의미하므로 클래스 이름은 **과거 시제**를 사용한다. (e.g. OrderCanceledEvent)

모든 이벤트가 공통으로 갖는 값이 존재한다면(e.g. 이벤트 발생시간) 관련 상위 클래스를 만들고, 이벤트 클래스가 해당 상위 클래스를 상속받아 구현할 수 있다.

#### Event 클래스와 ApplicationEventPublisher

이벤트 발생과 출판을 위해 스프링이 제공하는 `ApplicationEventPublisher` 을 사용한다.

```java
// 설정
@Configuration
public class EventsConfiguration {
    @Autowired
    private ApplicationContext applicationContext;

    @Bean
    public InitializingBean eventsInitializer() {
        return () -> Events.setPublisher(applicationContext);
    }
}
```

```java
// Events는 ApplicationEventPublisher를 사용해서 이벤트를 발생
public class Events {
    private static ApplicationEventPublisher publisher;

    static void setPublisher(ApplicationEventPublisher publisher) {
        Events.publisher = publisher;
    }

    public static void raise(Object event) {
        if (publisher != null) {
            publisher.publishEvent(event);
        }
    }
}
```

#### 이벤트 발생과 이벤트 핸들러

```java
// 이벤트 발생
public class Order {
    public void cancel() {
        //...생략...
        Events.raise(new OrderCanceledEvent(number.getNumber()));
    }
}
```

```java
// 이벤트 핸들러
@Service
public class OrderCanceledEventHandler {
    private RefundService refundService;

    public OrderCanceledEventHandler(RefundService refundService) {
        this.refundService = refundService;
    }

    @EventListener(OrderCanceledEvent.class)
    public void handle(OrderCanceledEvent event) {
        refundService.refund(event.getOrderNumber());
    }
}
```

#### 흐름 정리

이벤트 처리 흐름을 정리하면 아래 그림 10.7과 같다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-10-3.png)

위 그림과 같이 응용 서비스와 동일한 트랜잭션 범위 내에서 이벤트 핸드러를 실행하고 있다.

즉, 이벤트 핸들러는 같은 트랜잭션 범위에서 실행한다.


### 10.4 동기 이벤트 처리 문제

10.2 를 통해 강결합 문제를 해소되었지만, 외부 서비스에 영향을 받는 문제는 해결하지 못했다.

동기 문제로 발생한 문제는 다음과 같다.

* 외부 연동 과정에서 예외가 발생하면 트랜잭션 처리는?

* 이벤트 처리하는 코드가 느려지거나 예외가 발생하면?

이러한 문제를 해결하기 위해 이벤트를 **비동기로 처리**하거나 **트랜잭션을 연계**하는 것이다.

### 10.5 비동기 이벤트 처리

개발을 하다보면 'A 하면 일정 시간 안에 B 하라'는 내용을 담고 있는 요구사항이 있다.

실제로 예전에 온라인 강의를 결제했다가 취소했을 때, 결제 취소는 정상적으로 처리되었지만 내 통장에 들어오는 환불 금액은 3일 이내로 들어온 경우가 있다. (물론 요즘에는 기술이 발전이 되어서 결제 취소에 이어서 환불까지 바로 처리된 경우도 있지만 말이다..)

아무튼 여기서 'A 하면'은 이벤트로 볼 수 있다. 

즉, A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.


여기서 이벤트를 비동기로 구현하는 방법은 크게 네 가지로 생각할 수 있다.

* 로컬 핸들러를 비동기로 실행하기 

* 메시지 큐를 사용하기 

* 이벤트 저장소와 이벤트 포워더 사용하기 

* 이벤트 저장소와 이벤트 제공 API 사용하기

(각 구현 방식에 대한 자세한 내용은 필요할 때 책을 참고하자.)


### 10.6 이벤트 적용 시 추가 고려 사항

이벤트를 적용하다보면 다음과 같은 고려사항을 생각해봐야한다.

* 이벤트 소스를 EventEntry에 추가해야 할까?

  * EventEntry는 이벤트 발생 주체에 대한 정보를 갖지 않는다.

  * 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 없다.

  * 이 기능을 구현하려면 **이벤트에 발생 주체 정보**를 추가해야 한다.

* 포워더에서 전송 실패를 얼마나 허용해야 할까?

  * 특정 이벤트에서 계속 전송에 실패하면, 해당 이벤트로 인해 나머지 이벤트를 전송할 수 없게 된다.

  * 따라서 포워더를 구현할 때는 **실패한 이벤트의 재전송 횟수 제한**을 둬야한다. -> 정책이 필요하다.

* 이벤트 손실은?

  * 이벤트 저장소를 사용하면 이벤트 발생과 이벤트 저장을 하나의 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장할 수 있다.

  * 반면 로컬 핸들러를 이용해서 이벤트를 비동기로 처리하면 이벤트 처리에 실패하면 이벤트를 유실하게 된다.

* 이벤트 순서는?

  * 이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우, **이벤트 저장소**를 사용하는 것이 좋다.

  * 이벤트 저장소에 이벤트를 발생 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하기 때문이다.

  * 반면 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 순서가 다를 수 있다.

* 이벤트 재처리는?

  * 동일한 이벤트를 다시 처리해야할 때, 해당 이벤트의 순번을 기억해두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 방법이 있다.

  * 이 외에 멱등성으로 처리하는 방법도 있다.


#### 이벤트 처리와 DB 트랜잭션 고려

이벤트 처리를 동기/비동기로 할때 **이벤트 처리 실패와 트랜잭션 실패를 함께 고려**해야 한다.

트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 **경우의 수를 줄이면 된다.**

경우의 수를 줄이는 방법은 **트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것**이다.

* 스프링은 `@TransactionalEventListener` 어노테이션을 지원한다. 이를 통해 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있다.

```java
@TransactionalEventListener(
        classes = OrderCanceledEvent.class,
        phase = TransactionPhase.AFTER_COMMIT
)
public void handle(OrderCanceledEvent event) {
    refundService.refund(event.getOrderNumber());
}
```

위 코드에서 `TransactionPhase.AFTER_COMMIT` 값을 사용하면 **트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행**한다.

중간에 에러가 발생하면 트랜잭션이 롤백되어 핸들러 메서드를 실행하지 않는다.

이 기능을 사용하면 이벤트 핸들러를 실행했는데 트랜잭션이 롤백되는 상황은 발생하지 않는다.


## 11장. CQRS

`CQRS`는 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴이다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-11-1.png)

CQRS는 복잡한 도메인에 적합하다. 도메인이 복잡할 수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 난다.

CQRS를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 기능 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.

CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.

  * 명령 모델은 객체 지향에 기반해서 도메인 모델을 구현하기에 적당한 JPA 기술을 사용한다.

  * 조회 모델은 DB 테이블에서 SQL로 데이터를 조회할 때 MyBatis 기술을 사용한다.

아래 그림 11.4은 명령 모델과 조회 모델의 설계 예를 보여준다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-11-2.png)

또한, 아래 그림 11.5와 같이 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있다.

명령 모델은 트랜잭션을 지원하는 RDBMS를 사용하고, 조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL을 사용할 수도 있다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-11-3.png)

두 저장소 간 데이터 동기화는 10장에서 배운 **이벤트를 활용해서 처리**한다.

명령 모델에서 상태를 변경하면 이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달해서 변경 내역을 반영하면 된다.

명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우 **데이터 동기화 시점**에 따라 구현 방식이 달라질 수 있다.

(CQRS 패턴을 적용한다고 사용해야 할 필수 기술이 따로 존재하는 것은 아니다. JPA만 사용해서 명령 모델과 조회 모델을 구현할 수도 있다.)

대규모 트래픽이 발생하는 웹서비스에서 조회 속도를 높이기 위해 별도 처리를 하고 있다면, 명시적으로 명령 모델과 조회 모델을 구분하자.

이를 통해 조회 기능 때문에 명령 모델이 복잡해지는 것을 막을 수 있고, 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다.

### CQRS 장단점

> 장점

* 명령 모델을 구현할 때 **도메인 자체**에 집중할 수 있다.
  도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지 보수에 유리하다


* 조회 성능을 향상시키는 데 유리하다.
  조회 단위로 캐시 기술을 적용하거나 조회에 특화된 쿼리를 사용할 수 있다.


> 단점

* 구현해야 할 코드가 더 많다는 점이다.
  도메인이 단순하거나 트래픽이 많지 않은 서비스라면 굳이 조회 전용 모델을 따로 만들지 않아도 된다.

* 더 많은 구현 기술이 필요하다. 
  명령 모델과 조회 모델을 다른 구현 기술을 사용해야 하는 경우, 혹은 경우에 따라 다른 저장소를 사용할 때 필요한 기술을 알아야한다.
  또한, 데이터 동기화를 위한 메시징 시스템을 도입할 수도 있다.

이러한 장단점을 고려해서 CQRS 패턴을 도입할지 여부를 결정한다.

트래픽이 높은 서비스인데 단일 모델을 고집하면 유지보수 비용이 높아지기 때문에, 이 경우에 CQRS 도입을 고려하자.

---

## Review

> 9장. Review

* 도메인 주도 설계의 주요 개념 중 하나인 `바운디드 컨텍스트`에 대한 개념과 실무에서 어떻게 적용해야할 지 간단한 예시를 통해 이해는 했지만, 완전히 이해는 못했다.

* 하지만 해당 개념을 녹여서 실무에 적용해본다면, 코드간의 경계를 구분짓는데 용이해질것이라 생각한다.

* 또한, 컨텍스트를 통합할 때 모델간의 순수성을 지키기 위해 ACL을 사용하는 방법에 대해서도 알아봤다.

* 이 장을 통해 팀, 비즈니스, 아키텍처 수준에서 시스템을 바라보는 시각을 이전보다 더 넓게 갖게 된 것 같다.


> 10장. Review

* 동기 방식의 문제점을 해결하기 위해 이벤트를 사용해보는 것에 알게되었다. 이벤트가 어떻게 동작하고 스프링에서는 이벤트를 위해 제공하는 클래스가 무엇인지 알게되었다.

* 비동기로 처리하는 방법에 대한 예시 코드를 보면서 이해는 했지만, 실제 사용을 해봐야 감이 올 것 같다. 지금으로썬 70% 정도 이해한 것 같다.


> 11장. Review

* CQRS 패턴의 개념과 장단점에 알 수 있었다. 단순 개념과 예시가 들어있기 때문에, 실제 실무 환경에서 적용해봐야 제대로 이해할 수 있을 것 같다.

* 자세한 기술적 지식과 노하우에 대한 특별한 내용은 없어서 아쉬웠다.

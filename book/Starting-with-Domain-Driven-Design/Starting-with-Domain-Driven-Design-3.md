# 도메인 주도 개발 시작하기

이 글은 [도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지](https://product.kyobobook.co.kr/detail/S000001810495) 책을 읽고 정리한 내용이다.

아래 내용은 책에서 중요한/기억하고자하는 내용 위주로 정리했다. 자세한 내용은 책을 참고하자.


---

# 3장. 애그리거트

## 애그리거트

복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요하다. 이를 위한 방법이 바로 `애그리거트` 이다.

`애그리거트`는 관련 객체를 하나로 묶은 군집한 것을 의미한다.

수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-3-1.png)

위 **그림 3.3** 을 통해  모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 복잡한 도메인을 단순한 구조로 만들어준다.

복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력(개발 시간)도 줄어들게 된다.

애그리거트에 속한 객체는 **유사하거나 동일한 라이프사이클**을 갖는다. 위 그림 3.3 처럼 애그리거트는 경계를 갖으며, 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.

즉, 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신만을 관리한다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-3-2.png)

예를 들어, 상품과 리뷰를 살펴보자.

- 상품 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰 내용을 보여줘야 한다는 요구사항이 있다.
- 이때 Product 엔티티와 Review 엔티티가 하나의 애그리거트에 속한다고 생각하지만, Product 와 Review 는 함께 생성하지 않고, 함께 변경되지도 않는다.
- 그리고 Product를 변경하는 주체가 상품 담당자라면, Review를 생성하고 변경하는 주체는 고객이다.
- 이처럼 Review의 변경이 Product에 영향을 주지 않고, 반대인 경우도 영향을 주지 않기 때문에 이 둘은 한 애그리거트에 속한다기 보다는 서로 다른 애그리거트에 속한다.


## 애그리거트 루트

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요하다. 이 책임을 지는 것이 `애그리거트의 루트 엔티티`이다. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-3-3.png)

주문 애그리거트에서 루트 역할을 하는 엔티티는 Order 이다.

OrderLine, Shippinginfo, Orderer 등 주문 애그리거트에 속한 모델은 Order에 직접 또는 간접적으로 속한다.

애그리거트 루트의 핵심 역할은 **애그리거트의 일관성이 깨지지 않도록 하는 것**이다.

- 애그리거트 루트는 인터페이스 역할을 하기 때문에 **도메인 기준**으로 구현해야 한다.
- 이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-3-4.png)

### 트랜잭션 범위

트랜잭션 범위는 작을 수록 좋다.

한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 다르게 말하면 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.

한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한 번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.

이처럼 애그리거트는 최대한 서로 독립적어야 한다.

만약 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 `응용 서비스`에서 두 애그리거트를 수정하도록 구현한다.

도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서 동기 또는 비동기 방식으로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다. 이 부분에 대한 자세한 내용은 10장을 참고하자.

## 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 `애그리거트` 단위로 존재한다.

Order가 애그리거트 루트이고, OrderLine은 애그리거트에 속하는 구성요소이므로 Order를 위한 리포지토리만 존재한다.

보통 리포지토리는 다음의 두 메서드를 기본적으로 제공한다. 이 외에 필요에 따라 메서드를 추가할 수 있다.

- save: 애그리거트 저장
- findById: ID로 애그리거트를 조회

리포지토리는 애그리거트 전체를 영속화해야 한다. 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.

## ID를 이용한 애그리거트 참조

애그리거트 간의 참조는 `필드`를 통해 쉽게 구현할 수 있다.

하지만 애그리거트를 직접 참고하면 편리할 수 있지만, 다음과 같은 문제가 생길 수 있다.

- 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있어, 다른 애그리거트 객체의 상태를 쉽게 변경할 수 있다. 이는 애그리거트 간의 의존 결합도를 높여 결과적으로 애그리거트의 변경을 어렵게 만들 수 있다.
- 또한 성능과 관련된 여러가지 고민을 할 수 있다. (JPQL/Criteria 쿼리 등)
- 사용자가 늘고 트래픽이 증가하면서 확장성을 고려해야 하는데, 현재와 같이 단일 서버 및 단일 DB로 처리하는데 한계가 있다.

이러한 문제들을 해결하기 위해 사용할 수 있는 것이 `ID`를 이용해서 다른 애그리거트를 참조하는 것이다.

ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.

이는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다. 또한 애그리거트 간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.

구현 복잡도도 낮아진다. 참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 통해 로딩하면 된다.

애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다. 중요한 데이터인 주문 애그리거트는 RDBMS에 저장하고 조회 성능이 중요한 상품 애그리거트는 NoSQL에 저장할 수 있다.

![](/book/Starting-with-Domain-Driven-Design/img/Starting-with-Domain-Driven-Design-3-5.png)

ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 `조회 전용 쿼리`를 사용하면 된다.

특정 사용자의 주문 내역을 보여주는 요구사항이 있을 경우, JPQL를 이용해서 Order, Member, Product 애그리거트를 조인해서 조회하여 한 번의 쿼리로 로딩할 수 있다. 만약 쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 Mybatis 와 같은 기술을 이용해서 구현할 수도 있다.

그런데 애그리거트마다 서로 다른 저장소(DB가 여러대인 경우) 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다. 이런 경우에는 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다. 이 방법은 코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일 수 있다는 장점이 있다.

JPA에서 조회 전용 쿼리를 실행하는 방법은 5장에 있으니, 그 부분을 참고하자.

## 애그리거트를 팩토리로 사용하기

- 팩토리 취지는 애그리거트, 엔티티, 값 객체를 어떻게 생성할 것인지에 대한 `전략`에 대한 이야기이다.
    - 어떤 다른 곳에서 해당 객체를 생성할 때 생산자의 정보를 필요로 하는 것을 줄일 수 있다.
    - 아울러 생산자와 생성된 객체 사이의 특별한 관계를 전해주기도 합니다.
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 보자.

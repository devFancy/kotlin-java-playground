# Dev Practice - Commerce

## Development environment setup

### Git Hook
This setting makes run `lint` on every commit.

```
$ git config core.hookspath .githooks
```

### IntelliJ IDEA
This setting makes it easier to run the `test code` out of the box.

```
// Gradle Build and run with IntelliJ IDEA
Build, Execution, Deployment > Build Tools > Gradle > Run tests using > IntelliJ IDEA	
```


---

# 제미니의 개발실무 - 커머스 백엔드 기본편

> 아래는 인프런 강의인 [제미니의 개발실무 - 커머스 백엔드 기본편](https://www.inflearn.com/course/제미니의-개발실무-커머스-백엔드-기본/dashboard) 강의를 듣고 정리한 내용입니다.

여러 케이스에 대해 우리가 일을 어떻게 처리하고 개발할 것인지에 대한 생각을 여는게 중요하다. => "기술적 사고능력"

현재 상황과 맥락에 맞게 요구사항을 이해하면서 구현하자. (단, 스타트업 규모에서 과도한 아키텍처 설계는 지양하자.)

# 섹션 2. 상품 목록

## 요구사항 느끼기

PO/PM이 무슨 생각인지 요구사항을 이해해보고 질문을 던질 수 있어야 한다.
질문을 많이 해야 한다.

- 스크롤을 어떻게 보여줄 것인지
    - 최대 상품 갯수가 정해져 있는지
- 카테고리 안에서 정렬은 어떻게 해야하는지 -> 상품 ID로 할 것인지, 수정된 날짜 기준으로 할 것인지
    - 우선순위를 어떻게 정렬할지
    - 인기순으로 정렬하는건지
    - 최근 주문이 많은 순인지

기술적으로 고민해야할 부분 프론트엔드 개발자와 협의해봐야 하는 부분이 있다.
- 오프셋 방식 혹은 커서 방식으로 할지 -> 핵심은 스크롤이나 페이징할 때 어떤 방식으로 클라이언트와 데이터를 주고받을지 프론트엔드 개발자와 협의해야 한다.

요구사항에 대해 크게 두 가지로 나뉠 수 있다.
- 비즈니스에 대해서는 우리의 생각과 질문을 PO/PM과 협의하고,
- API 설계에 대해서는 프론트엔드 개발자와 미리 협의해야 한다.

소프트웨어를 개발할 때 교류를 많이 해야 한다.
- 나는 이렇게 생각하고 개발할 건데, 어떻게 생각하는지에 대한 "소통" 능력이 중요하고, 그로 인한 개발 리소스 비용도 줄일 수 있다.
- 기획자(PO/PM)으로부터 요구사항에 대한 **인사이트를 이해**하면서 클라이언트(프론트엔드 개발자)와 **소통을 하면서 맞춰야 하는 부분이 많다.**

회사를 들어가면, 일을 어떻게 해야하는지에 대한 생각을 많이 하자.
-> 면접을 본다거나 이력서를 정리할 때도 생각을 해보자. (+ 협업 경험)

## 코드 느끼기

- 상품 찾기를 `ProductFinder`와 같이 특정 행위 기준으로 이름을 지어서 만드는 스타일이다.
    - 스타일에 집중하기 보단 어떻게 구현을 했는지에 대한 생각을 해보자
    - 나는 어떻게 했을까? -> 추가 구현을 해보자.

- ProductFinder
    - DB 기준으로 카테고리, 상품을 만들었음 -> 이 둘을 이어주는 맵핑 테이블(productCategoryRepository)을 만들었음
    - 카테고리(1) : 상품(N)

## 개념 정리

- 개념간의 격벽을 세운다.
    - 여기서 말하는 `개념`은 클래스 혹은 엔티티가 아니다.
    - 코드랑 1대1로 맵핑을 안하는게 더 좋은 개념도를 그리는 방법이다.
    - 논리적인 지도라고 생각하면 좋다.

- 누구든지 쉽게 이해할 수 있게 만드는 것이 `개념도` 라고 볼 수 있다.
- 개념도를 작성하는 목적은 복잡한 시스템을 단순화하고 의존성을 명확하게 전달하는 것이다.


---

# 섹션 3. 상품 상세

## 요구사항 느끼기

![](/img/gemini-commerce/Gemini-Commerce-Product-Detail.png)

- 아래와 같은 요구사항이 추가될 수 있다.
    - 상품 이름, 상품 설명(Short Information), 상품 가격
    - 리뷰 수, 별점(Rate)
    - 상품과 연관된 쿠폰 다운로드
    - 찜하기(Favorite), 리뷰 버튼, Q&A 버튼
    - 상품 상세 설명(Full Information)에 대한 이미지 또는 HTML

- 다음과 같은 요구사항을 생각해볼 수 있다.
    - 상품 이미지가 몇 개인지
    - 상품 가격을 어떻게 측정하고 노출할 지 (원가, 원가 판매가, 할인가 -> 어떤 UI로 보여줄지, `금액 체계`를 서버 측면에서 어떻게 핸들링할지)
    - 커머스 시스템이 생기는 기능들이 **대부분 `상품 상세`에 들어올 가능성이 높다.**
    - 이렇게 (상품 상세 페이지에) 리뉴얼이 많이 되는 곳에 여러 개념이 묶여있는 곳이라면 구현을 어떻게 하는게 좋을까?
    - 전체를 조회하는 API를 구현할지, 아니면 개별로 조회하는 API를 구현할지
    - 회사마다 프론트엔드/백엔드 기준으로 맞추는 경우가 있다.
    - API 쪼개는 기준 -> 개념 단위별로 묶어서 구현하는게 이후 재사용성 면에서 좋다고 본다.
    - 예를 들어, API를 3개로 쪼개볼 수 있다.
        - 상품 - Product Image, Product Name, Short Information & Price
        - 리뷰 - Rate & Review Count
        - 쿠폰 - Related Coupons with Download
    - 요구사항 변할 때마다 API를 추가로 만들기 보다는 적절한 트레이드오프를 고려해봐야 한다.
    - (특히 앱의 경우) 백엔드한테 API는 한번 내보내면 계속(=오랜기간) 유지해야하는 경우가 많다.
        - 그렇기 때문에, 우리가 내부 개념을 어떻게 핸들링하는지가 중요하다.

## 코드 느끼기

- ProductController "강의를 활용하는 팁"
    - 코드 수정을 하면서 스스로 더 나은 방법이 없는지 생각해볼 것. -> Product <-> ProductSection 간의 관계(엔티티 기준)
    - Product: 상품 목록, 최근 본 상품 등등 -> 다양한 기능에 활용될 수 있음
    - ProductSection : 상품 상세에 국한되어있음

- 실제 회사에서는 강약각색의 코드가 존재하고, 이유가 있을 것임 -> 이유를 이해할 수 있는 자세를 갖는 것이 좋겠다.
    - '이런 이유가 있어서 이런식으로 코드를 짰겠구나' 식으로 이해해보자.

- 결론: 정답은 없다.

## 개념 정리

![](/img/gemini-commerce/Gemini-Commerce-Product-Detail-Concept.png)

- 상품이 직접적으로 리뷰, 쿠폰을 아는 상태가 아님.
    - API는 클라이언트에게 제공하기 위한 스팩으로,
    - 백엔드에서 내부적으로 중요하게 다루고 있는 서비스, 파인더를 봤을 때 직접적으로 리뷰, 쿠폰을 알고 있는 상태가 아니다.
    - API 프리젠테이션 레이어에서 조합해서 내려가는 형태로 되어있다.

- `상품 가격`은 왜 개념도에 없을까?
    - **중요 개념**이 아니기 때문.
    - 지금은 응집을 위한 클래스로 보이지만, 나중에 금액체계가 생기고 상품 형태가 많아질 경우 -> Product 하위가 아닐 수 있다.
    - 그렇기 때문에 개념도에 표현하기에 의미가 없다.
    - (반복해서 말하지만) **엔티티나 클래스가 개념도에 무조건 들어가는 건 아니다.**
    - 개념도에 들어가는 것은 **중요한 역할 또는 의미있는 역할을 하는 개념** 이다.

- 상품은 하위에 상품 카테고리, 상품 섹션이 있다.
    - 급수로 나눈다면 **2급**으로 볼 수 있다. -> `상품 카테고리`
    - `상품 섹션`은 상품 상세에만 사용하기 때문에, **3급**으로 볼 수 있다. -> 개념도에 꼭 필요할까? 부분도 생각해보자.
    - 필자는 `상품 섹션`을  3급으로 보고 있고 굳이 개념도에 안써도 괜찮다고 생각한다.


## QnA

제품 상세 페이지를 위해 API를 작고 집중된 부분으로 나눌 때의 장점은 무엇일까요?
- 답변: 향상된 장기 유지보수성과 모듈성

하나의 서비스가 리뷰와 쿠폰 같은 관련 없는 많은 개념을 알고 있는 것은 왜 문제가 될까요?
- 답변: 응집력과 순수성이 부족한 '갓 오브젝트'로 이어짐

제품 상세 페이지 설계에서 '제품 섹션' 엔티티의 주역할은 무엇인가요?
- 답변: 이미지나 HTML 같은 동적 콘텐츠의 UI 렌더링 지원하기

'가격'을 '제품' 내부에 포함시키지 않고 별도의 클래스나 엔티티로 분리하는 이유는 무엇일까요?
- 답변: 집계와 복잡한 계산이나 정책을 가능하게 하기 위해

개념적으로 분리된 백엔드 서비스의 데이터를 클라이언트를 위해 결합하는 역할을 하는 계층은 무엇인가요?
- 답변: API 프레젠테이션 계층 (컨트롤러)


---

# 섹션 4. 리뷰

## 요구사항 느끼기

![](/img/gemini-commerce/Gemini-Commerce-Review.png)

- 리뷰 작성하기
- 별점, 리뷰 내용
    - 무한 스크롤로 조회

> 요구사항에 대해 생각해보기

- 리뷰가 작성된 것에 수정 또는 삭제할 수 있는지 -> 할 수 있다면 그 기준이 무엇인지
    - 수정의 경우) 댓글을 달 수 있는지 -> 댓글을 달았는데, 말바꾸기와 같은 상황이 생긴다면 어떻게 할 것인지 -> 리뷰 시스템 정책에 대한 고민 (e.g. 수정/삭제 제안)

- 일반적으로 `리뷰`는 주문 결제를 해야 달 수 있음
    - 만약 상품을 5번 구매한 고객이 리뷰를 몇 번 쓸 수 있는지 -> 5번 쓸 수 있는가? 아니면 1번만 쓸 수 있는가?
    - 1년마다 이 제품을 구매한다면 -> 상품마다 리뷰를 써야하는게 아닌가? -> 서비스 경험 측면에서 "리뷰를 작성하는 기준"을 확인해야 한다.
    - 만약 고객이 5번 구매한 상품에 대해 각각 리뷰를 달았는데, 그 중 3개 상품에 대한 결제를 취소한다면, 기존 5개 리뷰에 대해 어떻게 할 것인지 -> 이런 부분에 대한 정책을 잘세워야 한다.
    - `리뷰`가 **`구매전환율`에 상당히 영향이 가는 부분**이 크다. -> 백엔드 개발 측면에서 고민을 해봐야 한다.

- 그 외 고민할 것들
    - 리뷰에 대한 댓글이 있는건지
    - 리뷰에 대한 별점이 몇점 만점인지, 소수점은 가능한지
    - 전체 기간에 대한 리뷰를 보여주는건지 -> 전체 기간이라면 리뷰 평점도 **전체 기간**의 평균 점수인건지, **최근 3개월** 구매한 상품의 리뷰 평점 점수인건지
    - 리뷰에 대한 보상을 무엇을 줘야할 것인지 -> 보상: **`포인트`** -> 이 리워드 정책은 어떻게 되는건지

## 코드 느끼기

- 리뷰 - 확장성 고려
    - 지금은 상품에만 달려있지만, 나중에는 판매자한테 리뷰를 할 수 있다든지 or 다른 기능에 리뷰가 추가될 수 있다든지 or 상품 옵션이 추가될 때 리뷰를 나눠서 할 수 있다든지와 같은 생각이 있을 수 있다.
    - 장기적으로 성장하다보면 플랫폼처럼 떼어질 수 있기 때문에 -> 보편화 시켜서 일반적이게 만들어보면 좋지 않나 싶음. -> 그런 측면에서 고민해보면 좋을 것 같다.

- 자세한 부분은 해당 코드를 참고한다.
    - ReviewService
        - ReviewPolicyValidator
        - ReviewManager -> 수정의 핵심 포인트 -> 앞으로 리뷰를 작성하는 요구사항의 변경이 생겼을 때 어떻게 할 것인지
    - 필자의 생각 Tip:
        - 자주 변하는 것과 핵심적인 것들을 나눠 가지고 관리하는 것(격리)을 선호한다.

- 나라면 어떻게 할지 -> 해당 코드를 수정해보면 좋을 것 같다. (좋은 케이스가 될 것 같다.)

## 개념 정리

![](/img/gemini-commerce/Gemini-Commerce-Review-Concept.png)

- 위 그림처럼 Order, Point 를 직접적으로 참조하므로 격벽을 넘는다고 볼 수 있다.

- 부수 개념으로 `리뷰 타켓`, `리뷰 내용` 을 볼 수 있다.

- 여기서 궁금한 점
    - 상품(Product) 가 안보인다. -> 리뷰는 범용적으로 작성할 수 있게 되어있다.
    - 정확히 말하면, 리뷰가 상품을 알고 있는 상태가 아니다.

- 리뷰는 확장성있게 만들어 놓은 형태이므로 실질적으로 다른 개념을 의존하는 형태가 아니므로 개념도에 표현하지 않았다.
    - 범용적으로 만들게 되면 개념도에서 의존을 줄일 수 있게 된다.
    - 논리적으로 '리뷰는 상품에 의존하고 있어' 하는 형태는 아님.

- 여기서 핵심은 리뷰가 어디에 의존하고 있는지 봐야 한다.
    - 리뷰를 남길 수 있는 주문(Order)이 있는지
    - 리뷰를 작성했으니까 포인트(Point)를 적립할 수 있는지 혹은 리뷰 삭제했으니까 포인트를 뺐을 수 있는지

## QnA

리뷰 편집이나 삭제 정책을 정의할 때 핵심 과제는 무엇인가요?
- 답변: 허용된 수정이나 삭제에 대한 기준 설정하기
- 해설: 리뷰 수정/삭제는 사용자 경험, 데이터 관리, 악용 방지 등 다양한 정책적 고려가 필요합니다. 단순한 허용 여부보다 구체적인 기준 설정이 중요할 수 있어요.

리뷰 시스템이 제품이 아닌 대상도 처리할 수 있게 하는 설계 개념은 무엇인가요?
- 답변: 일반적인 리뷰 대상 (유형 + ID)
- 해설: 리뷰 대상을 일반화하여 '타입과 ID'로 관리하면 상품 외 판매자 등 다양한 개체에 대한 리뷰도 유연하게 지원할 수 있습니다. 시스템 확장성을 위한 중요한 설계 방식입니다.

리뷰 시스템이 빈번한 요구사항 변경에 적응하기 위해 어떤 접근 방식이 유리할까요?
- 답변: 정책 로직을 중앙화하고 모듈화하기
- 해설: 이커머스 환경에서 요구사항은 자주 변합니다. 정책 관련 로직을 한데 모으고 모듈화하면 변경에 유연하게 대응하고 테스트하기도 쉬워집니다.

리뷰 작성 자격을 결정하는 기본적인 의존성은 무엇인가요?
- 답변: 주문과 결제 정보

아주 오래된 리뷰가 현재 제품 평가에 신뢰할 수 없다고 여겨지는 이유는 무엇일까요?
- 답변: 제품 품질이나 기능이 크게 변했을 수 있기 때문


---

# 섹션 5. Q&A

## 요구사항 느끼기

![](/img/gemini-commerce/Gemini-Commerce-QnA.png)

현실적으로 생각할 수 있는 부분들을 고려해보자.

- Q&A는 일반적으로 사용자가 질문하고 관리자(또는 운영자)가 답장하는 기능이라 볼 수 있다.

- 질문을 누가 남길 수 있는지
    - 구매 전에 아무 사용자가 남길 수 있는지 -> 정책 확인 필요
    - 어떤 상황에서 어떤 사람들이 사용할 수 있는지에 대한 구체적인 스펙이 필요하다.

- 추가적인 질문을 할 때 관리자 쪽에서 어떻게 처리할 것인지
- 1대1 문의를 어떻게 구축하고 운영할 것인지 -> 추후 개념도 설계할 때 참고할 수 있다.
- 질문을 할 때 비공개에 대한 질문이 있는건지
    - 1대1 문의의 경우 비공개가 있는 경우가 있음
    - 비공개할 경우 비밀번호를 어떻게 관리할지

- UI 면으로 봤을 때 질문한 걸 클릭했을 때 답변이 나오게 할 것인지 or 질문과 답변을 한 눈에 보게 할 것인지
    - 그에 따라 클라이언트와 API 설계를 어떻게 할지 협의할 수 있다.
    - Case 1) 질문 및 답변을 한 번에 API로 줄지 -> 만약 답변 내용이 길다면 어떻게 응답속도를 개선할 수 있는지 고민할 필요가 있음. -> 보완을 한다면 페이징 제한을 5개로 걸면 되긴 하다.
    - Case 2) 아니면 질문들을 모아서 API를 주고, 이후에 일부 질문을 클릭했을 때, 해당 답변을 호출하는 별도 API를 줄지
    - 이런 정책에 대한 얘기를 해보면 좋을 것 같다.
    - 이런 부분들은 서비스에 따라 다를 수 있다.


## 코드 느끼기

자세한 부분은 해당 코드를 참고한다.
- QuestionEntity(상품에 의존), AnswerEntity(질문에 의존)
- QnAController
- QnAService

- 해당 클래스의 필드들을 수정하면서 뭐가 아쉬운지에 대한 고민들을 생각해보면 가장 좋다.

## 개념 정리

![](/img/gemini-commerce/Gemini-Commerce-QnA-Concept.png)

QnA를 명시적으로 만들었음.

- 위 그림에서는 QnA -> Question, Answer 로 의존도를 표시했지만,
    - QnA -> Question -> Answer 로도 생각해볼 수 있다.

- 정확히 말하자면, Question -> Product를 의존하는게 맞다.

- 'QnA가 우리 회사에서 어떤 것에 의존적이지?' 라는 관점으로 생각해보면 좋을 것 같다.
    - **비즈니스 관점**으로 보면 좋을 것 같다.
    - **나만의 도메인을 정의하는 방법을 만드는 것**도 중요할 것 같다.
    - 결국은 이런게 선택지이고, 이 선택에 대한 건 비즈니스 or 기획 쪽에서 협의를 통해 도출되어야 한다.
    - 어떤 전략으로 개발하고 구현할지 -> 생각을 많이 하자. -> 그래야 개발을 더 잘하고 명확하게 할 수 있다.


## QnA

Q&A 기능 기획 시, 단순한 기능일지라도 무엇이 가장 중요할까요?
- 답변: 상세한 요구사항 정의

사용자 클릭 시 답변을 가져오는 방식의 Q&A API 설계 이유는?
- 답변: 답변 데이터 양이 많을 경우 성능 최적화

사용자용 Q&A API에서 답변 기능이 분리되는 주된 이유는 무엇일까요?
- 답변: 답변은 운영팀 등 특정 사용자만 처리하기 때문
- 해설: 답변 기능은 일반적으로 관리자나 운영팀 등 권한이 있는 특정 주체가 담당해요. 따라서 서비스 API와 분리하여 별도의 관리 시스템으로 처리하는 경우가 많습니다.

Q&A 개념에서 질문은 어떤 요소에 명시적으로 의존성을 가질까요?
- 답변: 제품

개발 전략 수립 시, 개발자 외에 어떤 팀과 협의해야 할까요?
- 답변: 비즈니스 및 기획팀
- 해설: 개발 전략은 기술적인 부분뿐만 아니라 비즈니스 목표와 서비스 방향을 고려해야 해요. 따라서 비즈니스 및 기획팀과의 긴밀한 협의를 통해 결정해야 합니다.


---

# 섹션 6. 찜하기

## 요구사항 느끼기

![](/img/gemini-commerce/Gemini-Commerce-Favorite.png)

위 그림은 '조회' 화면으로 보면 된다. -> 찜목록을 보여달라는 요구사항이 들어왔다.

- 상품 정보가 업데이트 됐을 때 -> 상품 가격 또는 상품 이름이 바뀔 때 찜 정보를 어떻게 할 것인지
    - 기존에 찜을 한 사람을 유지해줘야 할지 -> 정책적으로 고민해봐야 한다.
    - 상품 수정은 어드민쪽 API에서 하겠지만, API 수정할 때 모든 유저들의 데이터를 다 처리해야 하는 작업이 있을 수 있다.
    - 이러한 부분을 배치로 처리한다든지 or 이벤트 기반으로 처리한다든지 -> 꼭 이런 방식이 최선인지에 대해 시스템의 복잡도를 너무 키우지 않는 선에서 협의를 해보는게 좋다고 생각한다.

- 만약 찜이 비즈니스에 영향이 크고 중요한 개념이라면 빡세게 만들어야 한다.
    - 예를 들어, 찜에 대한 구매전환율이 상당히 높다. or 찜에 의한 결제가 훨씬 많다. -> 회사의 주 매출원

- 반대로, 비즈니스 영향이 적다면 굳이 실시간성으로 반영하는 기능을 개발하거나 알림 기능을 개발하는게 의미가 있는지 생각해봐야 한다.
    - 기본 버전에서 배포를 하고, 찜이 많이 쓰일 때 -> 그때 가서 구현을 해도 되지 않을까 싶다. (실무적으로 이런 경우가 많다.)

- 찜에 대한 유효기간이 없는지
    - 5년전에 찜해도 유지시킬 수 있는건지

- **따닥 이슈** (더블 클릭)
    - 찜하기/찜해제 -> 두 가지 상태가 존재한다고 가정했을 때 더블 클릭할 때 어떻게 할 것인지
    - 클라이언트가 어떤 식으로 API를 쓰기에 유도할 지 -> 서버 쪽에서 어떻게 구현할 지 협의를 해봐야 한다.

## 코드 느끼기

자세한 부분은 해당 코드를 참고한다.
- FavoriteEntity
- FavoriteController
- FavoriteService

## 개념 정리

![](/img/gemini-commerce/Gemini-Commerce-Favorite-Concept.png)

찜하기는 요구사항이 심플하게 정리가 되면 개념과 구현 자체는 간단하다.

- 만약 요구사항이 복잡해지면,
    - 어드민 쪽에서 상품 쪽이 변경되었을 때 -> 양방향 의존이 발생되는 것에 주의하자. -> 대안으로 이벤트 기반으로 처리한다 or 별도로 찜단에서 배치로 처리한다
    - (중요) **의존 관계를 계속 단순하게 유지하는 것에 집중**해야 한다.

- 개념도를 정리할 때 모든 클래스를 다 넣을 필요는 없다.
    - 그러면 대부분 개념이 유저를 의존하게 된다 -> 개념도를 볼 때 혼란스러워질 수 있다.
    - 그래서 유저와 같은 개념들은 기저에 깔려있다고 생각하고, 개념도 하단에 메모를 해두자.

## QnA

위시리스트와 쇼핑 카트의 주요 차이점은 무엇일까요?
- 답변: 위시리스트는 장기적인 관심사를 나타냅니다. (장바구니는 단기적인 구매 의도를 나타냅니다. )

좋아요 버튼을 빠르게 두 번 클릭할 때 발생할 수 있는 문제는 무엇일까요?
- 답변: 토글로 인한 UI 상태 불일치.

단일 API 엔드포인트로 위시리스트 추가와 제거를 어떻게 처리할 수 있을까요?
- 답변: 요청에 클라이언트 지정 상태를 사용합니다.
- 해설: 클라이언트가 요청 시 상태(추가 또는 제거)를 명시적으로 전달하면 됩니다. 이를 통해 서버는 클라이언트의 의도를 정확히 파악할 수 있어요.

서비스 개발자들이 일반적으로 데이터를 하드 삭제하지 않는 이유는 무엇일까요?
- 답변: 추적, 분석, 복구를 위해 데이터를 보존하기 위함입니다.
- 해설: 데이터를 완전히 삭제하지 않고 상태만 변경하여 추적, 분석, 복구 가능성을 유지하기 위함입니다. 이는 데이터의 가치를 보존하는 중요한 방법론이에요.

위시리스트와 같은 많은 이커머스 기능의 중심이 되는 엔티티는 무엇일까요?
- 답변: 상품


---

# 섹션 7. 포인트

## 요구사항 느끼기

![](/img/gemini-commerce/Gemini-Commerce-Point.png)

위 그림은 포인트 조회 화면이라고 이해하면 된다.

포인트를 적립하는 방식은 여러가지가 있다.
- 리뷰를 작성하면 포인트를 적립하는 방식. -> 즉시 지급인지 혹은 운영자가 수동으로 지급하는 방식인지
- 결제를 할때 포인트를 사용하는 방식 또는 포인트를 적립하는 방식 -> 두 가지가 동시에 일어나는 방식이 있다.

포인트별 정책
- 만료 기한
- 유효 기간
- 포인트 한도 금액
- 최소 100원부터 사용 가능한지
- 음수인 경우도 가능한지 -> e.g. 리뷰 작성하면 포인트 1000원 적립 -> 이후 다른 결제 건에 포인트 1000원 사용하고, 해당 리뷰를 삭제하면 포인트 -1000원이 쌓이면 결과적으로 -1000원이 되는데, 이 부분에 어떻게 대처할 것인지

포인트별 트래킹
- 건별로 포인트를 얼마 썻는지에 대한 기록을 추적해야 하는지 -> 기획 또는 정책적으로 포인트 관리 규칙이 명확해야 한다.


## 코드 느끼기

자세한 부분은 코드를 참고하자.
- PointController
- PointService
- PointHandler (메인이자 핵심!)

복잡하게 정책이 들어간다면
- 리뷰를 할 때 이미 포인트를 받은 상품이고, 한번만 받을 수 있는 상품이다.
- 그렇다면, 포인트 전 단계에 Validation 하는 컴포넌트와 같이 조합하는 방식으로 구현을 할 수 있을 것 같다.

요구사항을 상상해보면서 이 코드 베이스로 수정해보는 것도 좋은 방법이다.
- 혼자서 진행하면서 모르는 부분이나 궁금한게 있으면 질문주시면 될 것 같다.

## 개념 정리

![](/img/gemini-commerce/Gemini-Commerce-Point-Concept.png)

포인트는 리뷰, 결제할 때 적립 또는 차감되는 방식이다.
- PointBalance : 돈통 역할(총 포인트 잔액)
- PointHistory : 포인트 이력 -> 돈통에 문제가 생겼을 때, 포인트 이력으로 문제를 해결하는 구조로 중요한 역할이다.

포인트는 다양하게 사용되는 부분으로 완성도있게 유지되어야 좋을 것 같다.

---
